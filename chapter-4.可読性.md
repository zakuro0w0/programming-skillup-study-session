
<!-- TOC -->

- [1. 可読性の必要性について](#1-%E5%8F%AF%E8%AA%AD%E6%80%A7%E3%81%AE%E5%BF%85%E8%A6%81%E6%80%A7%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6)
    - [1.1. コードを読む時間 >>>越えられない壁>>> コードを書く時間](#11-%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E8%AA%AD%E3%82%80%E6%99%82%E9%96%93-%E8%B6%8A%E3%81%88%E3%82%89%E3%82%8C%E3%81%AA%E3%81%84%E5%A3%81-%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E6%9B%B8%E3%81%8F%E6%99%82%E9%96%93)
    - [1.2. 書くのは1回、読むのはN回](#12-%E6%9B%B8%E3%81%8F%E3%81%AE%E3%81%AF1%E5%9B%9E%E8%AA%AD%E3%82%80%E3%81%AE%E3%81%AFn%E5%9B%9E)
    - [1.3. コードの責任を取れるタイミングは最初の1回だけ](#13-%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AE%E8%B2%AC%E4%BB%BB%E3%82%92%E5%8F%96%E3%82%8C%E3%82%8B%E3%82%BF%E3%82%A4%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AF%E6%9C%80%E5%88%9D%E3%81%AE1%E5%9B%9E%E3%81%A0%E3%81%91)
- [2. インデント](#2-%E3%82%A4%E3%83%B3%E3%83%87%E3%83%B3%E3%83%88)
- [3. スペーシング](#3-%E3%82%B9%E3%83%9A%E3%83%BC%E3%82%B7%E3%83%B3%E3%82%B0)
- [4. コメント](#4-%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88)
    - [4.1. アンチパターン: 処理の内容をそのままコメントしている](#41-%E3%82%A2%E3%83%B3%E3%83%81%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3-%E5%87%A6%E7%90%86%E3%81%AE%E5%86%85%E5%AE%B9%E3%82%92%E3%81%9D%E3%81%AE%E3%81%BE%E3%81%BE%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B)
    - [4.2. アンチパターン: コードと二重管理になるコメントをしている](#42-%E3%82%A2%E3%83%B3%E3%83%81%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3-%E3%82%B3%E3%83%BC%E3%83%89%E3%81%A8%E4%BA%8C%E9%87%8D%E7%AE%A1%E7%90%86%E3%81%AB%E3%81%AA%E3%82%8B%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88%E3%82%92%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B)
        - [4.2.1. 型として定義する](#421-%E5%9E%8B%E3%81%A8%E3%81%97%E3%81%A6%E5%AE%9A%E7%BE%A9%E3%81%99%E3%82%8B)
        - [4.2.2. より汎用的に](#422-%E3%82%88%E3%82%8A%E6%B1%8E%E7%94%A8%E7%9A%84%E3%81%AB)
    - [4.3. 時間や数量の単位をコメントしている](#43-%E6%99%82%E9%96%93%E3%82%84%E6%95%B0%E9%87%8F%E3%81%AE%E5%8D%98%E4%BD%8D%E3%82%92%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B)
        - [4.3.1. NG](#431-ng)
        - [4.3.2. OK](#432-ok)
- [5. 命名](#5-%E5%91%BD%E5%90%8D)
    - [5.1. アンチパターン: true/falseの時に何を意味するか分からないbool](#51-%E3%82%A2%E3%83%B3%E3%83%81%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3-truefalse%E3%81%AE%E6%99%82%E3%81%AB%E4%BD%95%E3%82%92%E6%84%8F%E5%91%B3%E3%81%99%E3%82%8B%E3%81%8B%E5%88%86%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84bool)
        - [5.1.1. NG](#511-ng)
        - [5.1.2. OK](#512-ok)
    - [5.2. アンチパターン: 意図以外の情報ノイズを含む名前](#52-%E3%82%A2%E3%83%B3%E3%83%81%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3-%E6%84%8F%E5%9B%B3%E4%BB%A5%E5%A4%96%E3%81%AE%E6%83%85%E5%A0%B1%E3%83%8E%E3%82%A4%E3%82%BA%E3%82%92%E5%90%AB%E3%82%80%E5%90%8D%E5%89%8D)
    - [5.3. アンチパターン: 誰にも通じない省略](#53-%E3%82%A2%E3%83%B3%E3%83%81%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3-%E8%AA%B0%E3%81%AB%E3%82%82%E9%80%9A%E3%81%98%E3%81%AA%E3%81%84%E7%9C%81%E7%95%A5)
    - [5.4. アンチパターン: 責務が2つ以上ある名前](#54-%E3%82%A2%E3%83%B3%E3%83%81%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3-%E8%B2%AC%E5%8B%99%E3%81%8C2%E3%81%A4%E4%BB%A5%E4%B8%8A%E3%81%82%E3%82%8B%E5%90%8D%E5%89%8D)
        - [5.4.1. NG](#541-ng)
        - [5.4.2. OK](#542-ok)
    - [5.5. アンチパターン: 万能な名前](#55-%E3%82%A2%E3%83%B3%E3%83%81%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3-%E4%B8%87%E8%83%BD%E3%81%AA%E5%90%8D%E5%89%8D)
    - [5.6. アンチパターン: 否定形の名前](#56-%E3%82%A2%E3%83%B3%E3%83%81%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3-%E5%90%A6%E5%AE%9A%E5%BD%A2%E3%81%AE%E5%90%8D%E5%89%8D)
    - [5.7. アンチパターン: 他の要素で示すべきprefix](#57-%E3%82%A2%E3%83%B3%E3%83%81%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3-%E4%BB%96%E3%81%AE%E8%A6%81%E7%B4%A0%E3%81%A7%E7%A4%BA%E3%81%99%E3%81%B9%E3%81%8Dprefix)
        - [5.7.1. NG](#571-ng)
        - [5.7.2. OK](#572-ok)
    - [5.8. アンチパターン: 振る舞いと一致しない関数名](#58-%E3%82%A2%E3%83%B3%E3%83%81%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3-%E6%8C%AF%E3%82%8B%E8%88%9E%E3%81%84%E3%81%A8%E4%B8%80%E8%87%B4%E3%81%97%E3%81%AA%E3%81%84%E9%96%A2%E6%95%B0%E5%90%8D)
        - [5.8.1. NG](#581-ng)
        - [5.8.2. OK](#582-ok)
    - [5.9. アンチパターン: 状態と指示のどちらを表現しているのか曖昧な名前](#59-%E3%82%A2%E3%83%B3%E3%83%81%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3-%E7%8A%B6%E6%85%8B%E3%81%A8%E6%8C%87%E7%A4%BA%E3%81%AE%E3%81%A9%E3%81%A1%E3%82%89%E3%82%92%E8%A1%A8%E7%8F%BE%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B%E3%81%AE%E3%81%8B%E6%9B%96%E6%98%A7%E3%81%AA%E5%90%8D%E5%89%8D)
        - [5.9.1. NG](#591-ng)
        - [5.9.2. OK](#592-ok)
    - [5.10. 参考リンク](#510-%E5%8F%82%E8%80%83%E3%83%AA%E3%83%B3%E3%82%AF)

<!-- /TOC -->

<h1>chapter-4.可読性</h1>

- コードの読みやすさの重要性について触れる
- 可読性の定義は諸説あるが、一例として以下のようなコードを"可読性が高い"とする
	- 読む人によって意図の解釈がブレない
	- 無駄が無く、短く、簡潔である
	- 配置・構造が整っていて推測しやすい
		- コードの構造に関する説明は複雑度の話題が絡むため、別途説明する

# 1. 可読性の必要性について

## 1.1. コードを読む時間 >>>越えられない壁>>> コードを書く時間
- ソフト開発の中でコードを書く時間はとても短い
- 読む時間の方が圧倒的に長いのだから、読みやすさ、読む効率の方が重要

> 新規にコードを書く時間 : **5%**  
> 既存コードを修正する時間 : **25%**  
> コードを理解するために読む時間 : **70%**  
> [理解することが書き直すことを意味するとき](http://www.aoky.net/articles/jeff_atwood/when_understanding_means_rewriting.htm)より引用

## 1.2. 書くのは1回、読むのはN回
- 同じモジュールの開発を2人の設計者A/Bに見積もり依頼した場合...
	- 修正の度に何度でも、毎回異なる設計者が頑張って読まなければならない
	- 最初の開発(write)に時間が掛かっても、読みやすく(read)作る方が後で困らない

## 1.3. コードの責任を取れるタイミングは最初の1回だけ
- コードを読む人はレビュアだけではなく、以降そのコードに関わる不特定多数の設計者である
- コードに責任を持つ == コードの読み手に対して必要十分な説明を提供する
- コードレビューでレビュアに口頭で行う説明を、コード自身が語るように書くべき
	- コードに関わる全ての設計者がコードを読み始めるタイミングで、レビュアにしたのと同じ説明を逐一提供するべきだが、勿論そんなことは誰も出来ないし、したくない
	- コード自身に語らせることで、コードに対する説明責任を果たすことが出来る
	- コード自身が語るためには、コードは説明的でなければならない、故に可読性が重要

# 2. インデント
- ネスト階層の深さを表現したり、複数行に渡るコードの縦の見た目を揃えるために使われる
- 言語によってはインデントがスコープの範囲を定義するものもある
- スペーシング同様、formatterが提供する機能に任せて自動化するべき

# 3. スペーシング
- 括弧やカンマ等の区切り記号、型の修飾の前後に挿入する空白
- 基本的にはformatterが提供する機能に任せて自動化するべき
- vscode にもコード整形機能があり、ファイル保存時の自動整形も可能
- [プログラマーにちょっと役立つ英文句読法・スペーシングの原則 \| GMO メディア エンジニアブログ](https://tech.gmo-media.jp/post/44257688029/punctuation-rules) > 原則：句読点は左にくっつく

# 4. コメント
- コードで表現できない意図や事情を読み手に伝えるためのもの
- 基本的にはコードだけ(変数、関数、メンバの名前付け)で伝わるようにするべき
- 読み手は処理の詳細な手続きよりも、処理が何のためにあるのか、という**要約**を知りたい
- コメントすべきこと
	- 変数や定数の責務、役割
	- (命名に対して)何の略称なのか
	- 変数名、関数名だけで表現しきれない処理の背景や目的
	- 仕様書や設計書に記載の無い実装上の制約
	- ビジネスロジックや運用上の理由、政治的理由により必要となった変更の背景
- コメントすべきでないこと
	- 処理の詳細な内容そのもの
	- 適正な数値の範囲(最大値、最小値)など、コードと二重管理になるようなもの
	- 時間や数量の単位(コメントや変数名ではなく型で解決すべき問題、型で表現できない場合は名前またはコメントで明示するべき)


## 4.1. アンチパターン: 処理の内容をそのままコメントしている
- 見たら分かることはコメントする必要が無い
- 見ても分からないことをコメントして欲しい

```cpp
// フラグ設定
bool isXXXStarted = false;
```

## 4.2. アンチパターン: コードと二重管理になるコメントをしている
- NG 例では volume を int 型で扱っている
- isValidVolume()の中で最小値と最大値のチェックを行う
- Hoge::volume のコメントで isValidVolume()が行うチェックと同じコメントをしている
- 最小値最大値が変更になった時、volume の適正範囲に言及する全てのコメントが保守されない危険がある

```cpp
struct Hoge{
	int volume{10}; // 0以上100未満の値を取る
};

// volume値が適正な範囲に収まっているか否かを返す
bool isValidVolume(int volume){
	return volume >= 0 && volume < 100;
}

int main(){
	Hoge hoge{};
	if(isvalidVolume(hoge.volume)) {...}
}

```

### 4.2.1. 型として定義する
- 例えば以下のように、現在の値(value)と値の範囲チェッカ(isValid)を持つ型として見直す
- Volume を扱う側のコードは Volume の定義を見れば適正な範囲が分かる
- 適正な範囲のある値を int 等の基本型で運搬するのは危険

```cpp
struct Volume{
	int value{};
	Volume(int value) : value(value){}
	// valueが適正な範囲に収まっているか否かを返す
	bool isValid(){
		return value >= 0 && value < 100;
	}
};

struct Hoge{
	Volume volume{10};
};

int main(){
	Hoge hoge{};
	if(hoge.volume.isValid()) {...}
}
```

### 4.2.2. より汎用的に
- 値の範囲という考え方は Volume 以外にも当てはまるため、Range 型が必要な場合が有り得る
- 値の範囲を int 以外の型で扱いたい場合も有り得るため、int 部分を template で指定可能にする
- Volume::isValid()では範囲の具体的な数値を気にする必要は無くなり、Volume::range::isContains()に範囲のチェック方法を委譲する
- 例では記述量を抑えるため struct(既定で全て public)にしているが、実際には class としてアクセス制限を適切に施す必要がある

```cpp
template<class T>
struct Range{
	T min{};
	T max{};
	Range(T min, T max) : min(min), max(max){}
	// 引数valueが自身の範囲に収まっているか否かを返す
	bool isContains(T value){
		return min <= value && value < max;
	}
};

struct Volume{
	int value{};
	// Volumeの範囲はint型で[0, 100)とする
	Range<int> range{0, 100};
	Volume(int value) : value(value){}
	bool isValid(){
		return range.isContains(value);
	}
};

struct Hoge{
	Volume volume{10};
};

int main(){
	Hoge hoge{};
	if(hoge.volume.isValid()) {...}
}
```

## 4.3. 時間や数量の単位をコメントしている
- コメントや変数名ではなく型で解決すべき問題
- 型で表現できない場合は名前またはコメントで明示するべき

### 4.3.1. NG
```cpp
float sleep{1000}; // sleep時間[ms]
```

### 4.3.2. OK
```cpp
#include <chrono>
std::chrono::milliseconds sleep{1000};
```


# 5. 命名
- プロセス、ライブラリ、ファイル、クラス、関数、変数等、あらゆるものに対する名前付け
- コードの構造と並んで、設計者のセンスや実力が顕著に反映される項目である
- 名前がまともになるだけでもコードの可読性はかなりマシになる
	- 構造の設計で可読性を高めるにはトレーニングが必要だが、命名による可読性の向上はすぐに実践できる
- 命名はプログラムの動作には関係無い部分なのも相まって、その脅威は甘く見られがち
	- 塵も積もれば...なので絶対に手を抜いてはならない
	- 機械語みたいなコードを読みたいと思う人はいない

## 5.1. アンチパターン: true/falseの時に何を意味するか分からないbool
- bool関連の名前にcheck, flagは問答無用でNG
	- OKならtrueなのか、NGならtrueなのかが明示されていないため
- "このboolは何？"と聞かれた時には"trueだったら○○で、falseだったら××なやつ"と答えると思う
	- その説明をコード自身がするように名前を付けるべき
- [booleanメソッドの命名規則 - Qiita](https://qiita.com/GinGinDako/items/6e8b696c4734b8e92d2b)
- [真偽値を返す関数のネーミング - Qiita](https://qiita.com/yskszk/items/5a7f99c974773f03a82a)
- [やはりお前らの真偽値メソッド名は間違っている。 〜「Xxx できる？」系メソッドの命名〜 - Qiita](https://qiita.com/lovee/items/aa2125eb0bce4a9dde1f)

### 5.1.1. NG
```cpp
bool checkXXX();
bool startFlag;
```

### 5.1.2. OK
```cpp
bool isAvailableXXX();
bool isStarted{false};
```

## 5.2. アンチパターン: 意図以外の情報(ノイズ)を含む名前
```cpp
bool rc_bool;		// bool型であることを名前に含めている
bool blXXXFlag; 	// bool型であることを名前に含めている
bool gblXXXFlag;	// global変数のbool型であることを名前に含めている
int s4_xxxx;		// データサイズが4であることを名前に含めている
static void lf_func();	// local functionであることを名前に含めている
```

- 名前から型やデータサイズやglobalか否か、を知りたいのは何故なのか？
	- 何が嬉しいのか？定義から離れた場所でも型が分かると便利、とか？
		- シンタックスハイライトや定義の表示はエディタが提供してくれる
		- もしnotepad.exeでコーディングしているなら今すぐ捨てよう
	- コードが実現しようとする目的に関係の無い情報はノイズになるので要らない
- "同じファイルの他の関数では皆そう書いてるから、この関数だけ直すと統一感が無くなって可読性が落ちる"(実話)
	- 統一するなら可読性の高い方に合わせよう
	- 負債コード統一の可読性が本当に高いなら誰も苦労していない
	- ある要素を命名に含める合理性が"他でもそうしているから"以外に無ければ、それは意味が無い命名と見做すべき
- 文脈や処理の目的、意図を説明するために本当に型情報やデータサイズが必要なのか？を考え直すべき
	- この文脈で変数名からbool型であると分かった時に何が嬉しい？
		- bool型はisXXXとかhasXXXの名前からboolであると分かる
	- この文脈で変数のデータサイズが4byteだと分かった時のメリットは？
		- 型が変わったら名前のサイズ部分も逐一変更するのか？
	- 呼び出す関数がstaticなのかglobalなのかを呼び出し側が意識しなければならない理由は？
		- globalではなく、内部リンケージを持ったファイル内関数であることはstaticが付いてることから自明である
		- 普通のエディタなら関数名のマウスオーバーで定義が参照できるし、staticであることも分かる



## 5.3. アンチパターン: 誰にも通じない省略

```cpp
bool isExt;		// 外部映像が入力されているか否か、を表すらしい
bool chk;		// boolにcheck自体NGだが、"e" 1文字を省略する程忙しいのか？
void lf_func();	// lf=local function!? LineFeed(改行)かprintf()の書式指定%lfの方が先に出てくるだろう
#define XXX_CNTL_ON (1)	// 機能XXXがONである状態らしい、CNTL=control？？？
```

- 省略した命名は、世界的に市民権のある省略形のみに留めるべき
	- 試しに自分が考えた省略形をgoogleで検索してみよう
	- 十分に市民権を得た省略形であれば、省略しない単語と同等かそれ以上にhitするはず
		- "application" >> 約 4,500,000,000 件
		- "app" >> 約 15,900,000,000 件
- "isExt" : 当てはまる単語が複数ありそうな省略
	- "ext"から思いつく単語が複数あるのが問題、単一責務の原則に反する
		- extend, extension, extra, external, exit, exist,...
	- "外部映像入力"だったら"externalVideoInput"になるだろう
- "check" >> "chk" : 1文字だけ省略
	- この1文字省略でどれほど効率が上がるのか？
		- "chk？ああcheckのことか" と一瞬考えてしまい効率が落ちる事の方が深刻な問題
	- ほとんどのプログラミング向けエディタには補完機能がある
		- notepad.exe信者は補完機能を使ったことが無いので、1文字でも短く省略しようとする
		- 結果、書いた本人でさえ1週間で意味を忘れるような独自の単語が完成する
	- "短い方が書く効率が上がる"は理由にならない
		- エディタの補完機能を使えば名前の長さで効率は落ちない
		- 読む時間の方が圧倒的に長いのだから、書く効率よりも読む効率を重視するべき
		- 短い方が高効率なのであれば、機械語でコーディングすればよい
- "control" >> "cntl" : マイナーな省略
	- "cntl" >> 約 1,540,000 件
	- "ctrl" >> 約 413,000,000 件
	- どう考えてもctrlの方がメジャーで通じやすく、間違えにくい
	- ちょっと考えれば分かるけど何も考えずに読むのは難しい名前、が大量にあると頭の中でマッピングが必要になる
		- このマッピングが読む効率を落とすので、読む人に優しい命名をしよう
		- [CleanCode読書メモ - Qiita##メンタルマッピング](https://qiita.com/opengl-8080/items/c44814564cd216e50656#メンタルマッピングを避ける-p52)
- 独自の省略形が良くないのは、何の略なのかを示す情報がどこにも無いことが多いため
	- 出来る限り省略をしない、省略しても良いのは世界共通レベルに市民権のある単語だけ
	- どうにもならない制約で省略を余儀なくされるのであれば、何の略なのかを定義の傍に示すべき



## 5.4. アンチパターン: 責務が2つ以上ある名前
- 下のNG例では、`int ret`の責務が2つ以上ある
	- funcA()の戻り値を受け取る責務
	- funcB()の戻り値を受け取る責務
- funcA(), funcB()どちらも戻り値型がintである、という理由だけでretを使い回しているパターンが散見される
	- このパターンでは関数内の実行ステップにより`int ret`が表現する意味が変わってくる
		- "今見ているステップでは、retには何が入ってるんだっけ？"を考えなければならず、読む効率が落ちる
	- "戻り値の型が同じだから使い回す"ではなく、戻り値の意図まで同じか否かを考えるべき
	- `int ret`に"戻り値"以上の意味が無く、責務の範囲が広い命名をしている点も使いまわす要因となっている

### 5.4.1. NG
```cpp
bool test(){
	bool rc;
	int ret;
	rc = false;
	ret = funcA();
	if(ret == SUCCESS){
		ret = funcB();
		if(ret == SUCCESS){
			rc = true;
		}
	}
	return rc;
}
```

### 5.4.2. OK
```cpp
bool test(){
	return funcA() == SUCCESS && funcB() == SUCCESS;
}
```

## 5.5. アンチパターン: 万能な名前
```cpp
class XXXController;
class XXXManager;
class XXXUtiliry;
class CommonXXX;
```

- NG例のような名前には機能が集まりやすい
	- クラスの責務を一言で表せなくなった時、単一責務の原則に反するクラスが出来上がる
	- その内、あらゆる機能が集まった神の如きクラスが出来上がる
	- 神は作るべきではない

## 5.6. アンチパターン: 否定形の名前
- [真偽値を保持する変数（フラグ）の命名時に気をつけていること - Qiita](https://qiita.com/shouchida/items/22824645f1c9e76e3240)
- なるべく肯定系の名前を付けよう
	- disabledよりもenabled, prohibitedよりもallowed
- "XXXする"時にtrueで、"XXXしない"時にfalseの方が人間にとって理解しやすい
	- "XXXしない"時にtrue、が混ざっていると、頭の中で一度ひっくり返して考える必要が出てくる
	- この手間がコードを読む効率を落としたり、読み間違いによる設計ミスを招いたりする
- 以下のような場合は止むを得ず否定形を採用する、または別の単語への置き換えを検討する
	- 適切な対義語としての肯定系が存在しない単語
	- 否定形は有名だが、肯定系はマイナーな単語

```cpp
bool isProhibitedXXX();
bool isDisabledXXX();
bool isNotXXX();
```

```cpp
// 型名だけ見ると"操作の禁止"という要素は見当たらない
struct PLAY_ACTION{
	// 変数名からtrue, falseの時に何なのかが全く分からない
	bool vol_ctl{false}; // 音量変更の有効/無効(true:利用できない, false:利用できる)
	bool pause{false};	// 一時停止の有効/無効(true:利用できない, false:利用できる)
};

struct REQ_PLAY{
	// PLAY_ACTION型のインスタンス名で"禁止"を表現している、最悪である
	// インスタンス名はPLAY_ACTIONの実体を生成する人が
	// 自由に決められるのだから、enableActという名前で生成されてもおかしくない
	PLAY_ACTION disableAct{};
};
```

## 5.7. アンチパターン: 他の要素で示すべきprefix
- 名前空間やパッケージ名、クラス名で示すべき名前を関数名、変数名に付けるのはNG
	- C言語にはnamespaceもpackageも無いが、少なくとも内部リンケージを持ったstaticな関数/変数についてはprefix不要
	- globalなものの名前重複を避ける目的であれば、prefixが必要な場面はある

### 5.7.1. NG
```cpp
void SVNT_HttpClient_send();
```

### 5.7.2. OK
```cpp
namespace server::network{
	class HttpClient{
		void send();
	};
}
```

## 5.8. アンチパターン: 振る舞いと一致しない関数名
- 何かを取得したり、判定したりしそうな名前の関数の戻り値をvoidにするのは避けよう
	- これらの多くは関数内でstaticな変数を書き換える副作用付きの実装が為されている
	- 引数に参照やポインタを渡し、そこに結果を貰うタイプの実装は避けよう
		- "戻り値だと実体を返すことになるから、コピーコストが掛かってしまう！"
			- C++の場合は[RVO](http://cpp.aquariuscode.com/return-value-optimization)が効くのでコピーコストはほぼ掛からない
		- "bool戻り値で取得の成否を返しつつ、引数のポインタに結果を格納したい！"
			- 処理の成否は戻り値ではなく例外で知らせるべき場合が多い
			- 複数の値をセットで返したい場合は`std::pair<T1, T2>`等を使う選択肢もある
- 何かを入力しそうな名前の関数の引数を無しにするのも避けよう
	- 戻り値voidの時と同様に、メンバ変数やstatic変数を内部で扱う実装になりやすい
- 副作用を関数から除去しつつ、戻り値をstatic変数に受け取るようにしたり、static変数を引数に渡したりするべき

### 5.8.1. NG
```cpp
static int xxx;
static bool yyy;
// getにも関わらず戻り値がvoid
void getXXX(){
	xxx = funcA();
}
// bool判定のような名前にも関わらず戻り値がvoid
void isEnabledYYY(){
	yyy = funcB();
}
// setにも関わらず引数無し
void setXXX(){
	funcC(xxx);
}

int main(){
	getXXX();		// getした結果はどこに行った？を怪しむべき
	isEnabledYYY();	// 判定した結果はどこに行った？を怪しむべき
	setXXX();		// 何をsetしているのか？を怪しむべき
}
```

### 5.8.2. OK
```cpp
static int xxx;
static bool yyy;

int getXXX(){
	return funcA();
}

bool isEnabledYYY(){
	return funcB();
}

void setXXX(int xxx){
	funcC(xxx);
}

int main(){
	xxx = getXXX();
	yyy = isEnabledYYY();
	setXXX(xxx);
}
```

## 5.9. アンチパターン: 状態と指示のどちらを表現しているのか曖昧な名前
- NG例の`isStop`では複数の解釈が可能であり、責務が曖昧である
	- 停止したか否か？(状態) >> is + 過去分詞形
	- 停止中なのか否か？(状態) >> is + 現在分詞形
	- 停止すべきなのか否か？(指示) >> should/needs + 動詞

### 5.9.1. NG
```cpp
void test(bool isStop);
```

### 5.9.2. OK
```cpp
void test(bool isStopped);	// 停止したか否か、の状態を表す場合
void test(bool isStopping);	// 停止中か否か、の状態を表す場合
void test(bool shouldStop);	// 停止すべきか否か、の指示を表す場合
```



## 5.10. 参考リンク
- [プログラミングでよく使う英単語のまとめ【随時更新】 - Qiita](https://qiita.com/Ted-HM/items/7dde25dcffae4cdc7923)
- [きれいなソースコードを書くために必要な、たったひとつの単純な事 - よくわかりません](https://r-west.hatenablog.com/entry/20090510/1241962864)
- [そのソースコードが汚い理由：共通した根源的な間違い - よくわかりません](https://r-west.hatenablog.com/entry/20090516/1242489952)
- [プログラミングで変数名や関数名のネーミングに迷ったときに便利なカンニングペーパーまとめ](https://nelog.jp/programming-words)
- [関数や変数のネーミングに悩んだら「codic」に日本語名を入力するとある程度解決するかも](https://nelog.jp/codic)
- [GitHub - codic-project/codic-vscode-extension: codic extension for Visual Studio Code](https://github.com/codic-project/codic-vscode-extension)
